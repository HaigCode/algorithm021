#1.capacity
capacity <<= 1：
```java 
int i  = 1;

//类似于 i++就是 i = i+1;的这结构
//i = i<<1  i等于i乘以2的1次方
//i <<= 1;
//i = i<<2  i等于i乘以2的2次方,>>就是相除了
i <<= 2;
System.out.println("结果是：" + i);
```
# 2.java中有三种移位运算符：
```
// <<：左移运算符，num << 1,相当于num乘以2
// >>：右移运算符，num >> 1,相当于num除以2
// >>>：无符号右移，忽略符号位，空位都以0补齐
无符号右移的规则只记住一点：忽略了符号位扩展，0补最高位 无符号右移运算符>>> 只是对32位和64位的值有意义
```

# 3.什么是哈希冲突
- 哈希计算就是努力的把比较大的数据存放到相对较小的空间中。最常见的哈希算法是取模法。
- 取模法：数组的长度是5。这时有一个数据是6。那么如何把这个6存放到长度只有5的数组中呢。按照取模法，计算6％5，结果是1，那么就把6放到数组下标是1的位置。那么，7就应该放到2这个位置。到此位置，冲突还没有出现。这时，有个数据是11，按照取模法，11％5＝1，也等于1。那么原来数组下标是1的地方已经有数了，是6。这时又计算出1这个位置，那么数组1这个位置，就必须储存两个数了。这时，就叫哈希冲突。冲突之后就要按照顺序来存放了。
- 如果数据的分布比较广泛，而且储存数据的数组长度比较大。那么哈希冲突就比较少。否则冲突是很高的。

# 4.HashMap就是一个散列表，它是通过“拉链法”解决哈希冲突的
## 4.1.什么是拉链法：
- 拉链法又叫链地址法，拉链法就是把具有相同散列地址的关键字(同义词)值放在同一个单链表中，称为同义词链表。有m个散列地址就有m个链表，同时用指针数组T[0..m-1]存放各个链表的头指针，凡是散列地址为i的记录都以结点方式插入到以T[i]为指针的单链表中。T中各分量的初值应为空指针.
简单来说拉链法就是数组加链表。
- 大方向上，HashMap 里面是一个数组，然后数组中每个元素是一个单向链表。
- 嵌套类 Entry 的实例包含四个属性：key, value, hash 值和用于单向链表的 next。


### 4.2.从HashMap的实现来看，我们总结拉链法的实现步骤如下：
1. 计算 key 的 hashValue
2. 根据 hashValue 值定位到 table[hashIndex] ( table[hashIndex] 是一条链表Node)
3. 若 table[hashValue] 为空则直接插入，不然则添加到链表末尾。

### 4.3.要点
- HashMap 是一个散列表，它存储的内容是键值对(key-value)映射。
- HashMap 继承于AbstractMap，实现了Map、Cloneable、java.io.Serializable接口。
- HashMap 的实现不是同步的，这意味着它不是线程安全的。它的key、value都可以为null。此外，HashMap中的映射不是有序的。
- HashMap 的实例有两个参数影响其性能：“初始容量” 和 “加载因子”。容量 是哈希表中桶的数量，初始容量 只是哈希表在创建时的容量。加载因子 是哈希表在其容量自动增加之前可以达到多满的一种尺度。当哈希表中的条目数超出了加载因子与当前容量的乘积时，则要对该哈希表进行 rehash 操作（即重建内部数据结构），从而哈希表将具有大约两倍的桶数。
默认加载因子是 0.75,如果初始容量大于最大条目数除以加载因子，则不会发生 rehash 操作。
- HashMap是通过"拉链法"实现的哈希表
- 默认的初始容量是16，必须是2的幂。
- 最大容量（必须是2的幂且小于2的30次方，传入容量过大将被这个值替换）
//链表长度大于8时，将链表转化为红黑树
//如果发现链表长度小于 6，则会将红黑树重新退化为链表
- 因为红黑树的平均查找长度是log（n），长度为8的时候，平均查找长度为3。。如果继续使用链表，平均查找长度为8/2=4。这才有转换为树的必要。。链表长度如果是6以内，6/2=3，速度也很快的。转化为树还有生成树的时间，并不明智。中间有个差值，还可以防止链表和树频繁转换。
